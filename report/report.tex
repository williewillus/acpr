\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}

\begin{document}

\title{Asynchronous I/O for \texttt{cp -r}}
\date{\today}
\author{Vincent Lee \\
        Gualberto A. Guzman}

\maketitle

\section{Goals}

Our project proposal is to use Linux's asynchronous IO interfaces (aio) to build
an optimized version of cp -r. Our implementation will take an existing
directory name and a new name and copy the entire directory tree to the location
specified.

\section{Major Decisions and Challenges} 

There were two major choices available to us for asynchronous file IO on Linux.
The first was the \textbf{POSIX AIO} interface, which is standardized as a set
of library calls across all POSIX-compliant environments. However, according to
the man pages, glibc simulates POSIX AIO completely in userspace~\cite{aio7}.
This means that the kernel is not able to make scheduling and reordering
decisions that may affect performance. Instead, we decided to use the
nonportable \textbf{Linux AIO} system calls.

For the implementation itself, \textbf{C++} was chosen as the programming
language. In addition to being a fast systems programming language, it also
provides useful abstractions and standard libraries, as well as access to the
Boost libraries. The Boost Filesystem library was used for its
\texttt{recursive\_directory\_iterator}, an iterator which yields all paths
along a breadth-first traversal from a given root path. For each path, if the
file is small enough, it is copied directly using a Boost call. This is because,
below a certain point, the overhead of initializing and submitting an
asynchronous IO task dominates the cost of simply using \texttt{read} and
\texttt{write}. This threshold is configurable and the effects of varying it are
explored in Section 4.

A function critical to our implementation,
\texttt{boost::filesystem::relativize}, was missing in the version of Boost
installed on the lab computers. This function takes two absolute paths and makes
one into a path relative to the other, so that it can be appended to the
destination directory. We backported this function from later Boost versions by
simply copying the relatively small implementation from the Boost source
control.

The userspace header library that wrapped the Linux AIO system also implemented
a particular call naively. \texttt{io\_queue\_run} is a function that polls the
kernel event queues and runs callbacks. However, we looked at the implementation
and discovered that it was receiving events one by one, making a system call for
every single one. We replaced calls to this function with direct system calls to
read the event queue ourselves, resulting in about 64 events per system call
instead of 1.

During early testing, we attempted to copy the Linux 4.4 kernel tree, a 711 megabyte repository of mostly small files. acpr used over 7 minutes before it was killed, while cp used only 1 second. Some profiling indicated that the AIO subsystem finished very quickly, it was the \texttt{fsync} call for each file that slowed everything down. Disabling the \texttt{fsync} by default sped the copy up to about 3 seconds. We verified that \texttt{cp} also chose not to call it by observing the system calls it made using \texttt{strace}.

\section{Limitations}

Attributes and ownership are currently not copied properly. Symbolic links are skipped.

\section{Evaluation}

\section{Conclusion}

\section{Time Spent}

About 1.5 hours were spent researching the state of asynchronous IO, finding
documentation for the chosen libraries, and setting up the build system of the
project.

\begin{thebibliography}{99}
        \bibitem{aio7}
        aio (7), http://man7.org/linux/man-pages/man7/aio.7.html
\end{thebibliography}

\end{document}
